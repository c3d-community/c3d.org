"use strict";(globalThis.webpackChunkc_3_d_org=globalThis.webpackChunkc_3_d_org||[]).push([[7326],{4331:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>r,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"appendix/choosing-a-c3d-format/sample-rate-limitations","title":"Sample Rate Limitations","description":"All C3D files support a single sample rate for POINT data and a single sample rate for ANALOG data.  The ANALOG sample rate is always either the same as the POINT rate or an integer multiple of the POINT rate.  While this may seem restrictive, it ensures that the ANALOG data is always stored in synchronization with the POINT data.  In addition, this restriction allows any application to easily calculate the exact location of any individual frame of data within the C3D file thus making data access simpler and faster and regardless of the length of the data collection, ensured that the analog samples can always be synchronized with the 3D data samples.","source":"@site/docs/appendix/choosing-a-c3d-format/sample-rate-limitations.md","sourceDirName":"appendix/choosing-a-c3d-format","slug":"/appendix/choosing-a-c3d-format/sample-rate-limitations","permalink":"/c3d.org/appendix/choosing-a-c3d-format/sample-rate-limitations","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Sample Rate Limitations"},"sidebar":"tutorialSidebar","previous":{"title":"Parameter interpretation","permalink":"/c3d.org/appendix/choosing-a-c3d-format/c3d-parameters/parameter-interpretation"},"next":{"title":"Integers and Bytes","permalink":"/c3d.org/appendix/integers-and-bytes/"}}');var i=a(4848),n=a(8453);const r={title:"Sample Rate Limitations"},o=void 0,l={},h=[];function d(e){const t={p:"p",...(0,n.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"All C3D files support a single sample rate for POINT data and a single sample rate for ANALOG data.  The ANALOG sample rate is always either the same as the POINT rate or an integer multiple of the POINT rate.  While this may seem restrictive, it ensures that the ANALOG data is always stored in synchronization with the POINT data.  In addition, this restriction allows any application to easily calculate the exact location of any individual frame of data within the C3D file thus making data access simpler and faster and regardless of the length of the data collection, ensured that the analog samples can always be synchronized with the 3D data samples."}),"\n",(0,i.jsx)(t.p,{children:"In a data collection environment where multiple sensors exist that are being sampled at different rates, the C3D format expects that the data collection system recording the data will resolve these sampling issues and generate a C3D file with a single analog sample rate once the data collection is completed.  So the approach to support different analog devices, each with a unique sample rate, is essentially a hardware data collection issue.  Data collection systems can record a raw data file (or files) from devices with multiple sample rates and then process each data stream to generate a single sample rate that is a multiple of the 3D frame rate, and write that to the C3D file."}),"\n",(0,i.jsx)(t.p,{children:"If a data collection system has three incoming data streams, e.g. video data at 120Hz frame rate, EMG data sampled at 900 samples a second (450Hz bandwidth), and force plate data at 50 samples/sec (25Hz bandwidth) then the data collection system writes the data to the C3D file at a common analog sample rate that is a multiple of the video frame rate - in this example it is 1800 samples/sec which means that the C3D file will be written with 15 analog samples from each data source per 3D frame."}),"\n",(0,i.jsx)(t.p,{children:"This creates a synchronization lock and maintains the analog signal bandwidth - there will be 15 analog samples per channel, per 120Hz frame which effectively translates writing two EMG samples to the C3D file for each sample that the EMG system sends, and 36 force data samples for each sample that the force plate sends.  The data recorded in the C3D file will be accurate measurements of the data from the sensors.  Optionally the data collection system can resample the incoming data to make the recorded data look like it has been sampled at a higher bandwidth but this is effectively pre-processing the sensor data and should not be the default option although it might be needed if a sensor has a sample rate that doesn\u2019t match the 3D sample rate."}),"\n",(0,i.jsx)(t.p,{children:'While the C3D format stores data synchronized to the 3D frame data, an "analog channel" is essentially just a stream of 16-bit data with associated parameters that describe the stored values.  It is written frame by frame in the C3D file with the physical synchronization determined by the data collection system that writes the file.  When the data is read, users assume that it\'s been written on a frame by frame lock but that is not always the case.  When analog data is sampled from a hardware system with significant latencies (a common issue in Wi-Fi and Bluetooth radio-telemetry) the delayed data may be written to the C3D file causing a loss of synchronization, potentially causing post-collection analysis and data processing issues if the individual sensor latency has not been verified.'}),"\n",(0,i.jsx)(t.p,{children:"While the C3D format writes the analog data sample in sync with the 3D frames, the actual relationship between the data is determined by the software that creates the C3D file.  A potential problem exists when the sensors generate digital samples that are presented to the C3D file creation environment at a unique sample rate that needs to be resynchronized to the video frame rate, resulting in potential sampling errors and undocumented latencies.  As a result the data resampling results in C3D files that only store calculated values, not physical measurements."})]})}function c(e={}){const{wrapper:t}={...(0,n.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>r,x:()=>o});var s=a(6540);const i={},n=s.createContext(i);function r(e){const t=s.useContext(n);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),s.createElement(n.Provider,{value:t},e.children)}}}]);