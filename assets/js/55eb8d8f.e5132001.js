"use strict";(globalThis.webpackChunkc_3_d_org=globalThis.webpackChunkc_3_d_org||[]).push([[5278],{2545:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"the-3d-point-data-section/analog-data-section/analog-data-integer-format/index","title":"Analog Data - Integer Format","description":"When storing analog data using the integer C3D format, each binary sample value generated by the ADC is stored as a 16-bit integer.  By default these samples were originally stored as signed integer values although common ADC resolutions meant that all recorded values fell into the range of 0 to 32767 as positive values \u2013 negative integer sample values do not exist.","source":"@site/docs/the-3d-point-data-section/analog-data-section/analog-data-integer-format/index.md","sourceDirName":"the-3d-point-data-section/analog-data-section/analog-data-integer-format","slug":"/the-3d-point-data-section/analog-data-section/analog-data-integer-format/","permalink":"/c3d.org/the-3d-point-data-section/analog-data-section/analog-data-integer-format/","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Analog Data - Integer Format"},"sidebar":"tutorialSidebar","previous":{"title":"Notes for programmers - Floating-point Analog Data","permalink":"/c3d.org/the-3d-point-data-section/analog-data-section/analog-data-floating-point-format/notes-for-programmers-floating-point-analog-data"},"next":{"title":"Notes for programmers - Integer Analog Data","permalink":"/c3d.org/the-3d-point-data-section/analog-data-section/analog-data-integer-format/notes-for-programmers-integer-analog-data"}}');var o=a(4848),s=a(8453);const i={title:"Analog Data - Integer Format"},r=void 0,l={},d=[];function g(e){const t={li:"li",p:"p",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.p,{children:"When storing analog data using the integer C3D format, each binary sample value generated by the ADC is stored as a 16-bit integer.  By default these samples were originally stored as signed integer values although common ADC resolutions meant that all recorded values fell into the range of 0 to 32767 as positive values \u2013 negative integer sample values do not exist."}),"\n",(0,o.jsxs)(t.p,{children:["While 12-bit resolution ADC samples are common, other resolutions (i.e.,14-bit or 16-bit) may be used to store analog data. The resolution of the data may be recorded by the ANALOG",":BITS"," parameter.  Both 12-bit and 16-bit analog sample resolutions are common although 16-bit samples may be interpreted incorrectly by applications written to read the ADC samples as signed integers."]}),"\n",(0,o.jsx)(t.p,{children:"To convert the analog sample data into physical world units, regardless of the actual sample resolution:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"physical world value = (data value - offset) * channel scale * general scale"}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"Where:"}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsxs)(t.li,{children:["\u2018offset\u2019 is in the \u201cANALOG",":OFFSET","\u201d parameters (integer)"]}),"\n",(0,o.jsxs)(t.li,{children:["\u2018channel scale\u2019 is in the \u201cANALOG",":SCALE","\u201d parameters (floating-point)"]}),"\n",(0,o.jsxs)(t.li,{children:["\u2018general scale\u2019 is the \u201cANALOG",":GEN_SCALE","\u201d parameter (floating-point)"]}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["Analog data samples are stored in a C3D file as signed integers by default although an analog to digital converter (ADC) normally generates unsigned binary values.  When generated by an ADC with up to 14-bit resolution, the sampled data can be stored within the range of values supported by the signed integer format.  For example a 12-bit ADC generates numbers in the range of 0 through 4095.  These values may be written to the C3D file as \u20132048 through +2047 or simply recorded as 0 through 4095.  The first range is signed (it contains both positive and negative numbers), while the second range is unsigned.  In this case, the use of signed or unsigned integers to store the analog sample is immaterial as both values fall within the range of a signed integer.  However, this is not the case when 16-bit ADC samples are stored; in this case the 16-bit data samples must be stored as signed integer numbers (the default) unless the optional parameter ANALOG",":FORMAT"," is set to UNSIGNED."]}),"\n",(0,o.jsxs)(t.p,{children:["In the absence of the ANALOG",":FORMAT"," parameter, the format of the analog data can be determined by reading the ANALOG",":OFFSET"," parameter.  12-bit unsigned binary values require an OFFSET of 2047 (although many programs use 2048 because their author didn\u2019t realize that 0 is a valid number), while signed binary data will have an OFFSET of 0000.  16-bit unsigned analog data will require an OFFSET of 32767 while 16-bit signed binary data will use an OFFSET of 0000."]})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(g,{...e})}):g(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>i,x:()=>r});var n=a(6540);const o={},s=n.createContext(o);function i(e){const t=n.useContext(s);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);