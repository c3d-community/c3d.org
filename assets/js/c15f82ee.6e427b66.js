"use strict";(globalThis.webpackChunkc_3_d_org=globalThis.webpackChunkc_3_d_org||[]).push([[5538],{7522:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"glossary-of-terms","title":"Glossary of Terms","description":"This glossary contains definitions of terms used in the C3D documentation.  In some cases, terms such as record, blocks, and section, are used in ways that may appear unconventional to many users with a traditional programming background.  The use of these terms in this manual is an attempt to describe the C3D format in a coherent fashion as a vehicle for the accurate storage of universally accessible data in the 3D biomechanics motion capture environment.","source":"@site/docs/glossary-of-terms.md","sourceDirName":".","slug":"/glossary-of-terms","permalink":"/glossary-of-terms","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Glossary of Terms"},"sidebar":"tutorialSidebar","previous":{"title":"Data encryption","permalink":"/application-parameters/the-subjects-group/data-encryption"},"next":{"title":"Required Parameters","permalink":"/required-parameters/"}}');var i=t(4848),r=t(8453);const s={title:"Glossary of Terms"},o=void 0,l={},d=[{value:"3D Data",id:"3d-data",level:2},{value:"3D Frame",id:"3d-frame",level:2},{value:"3D Point",id:"3d-point",level:2},{value:"ASCII",id:"ascii",level:2},{value:"ADC",id:"adc",level:2},{value:"Analog Data Sample",id:"analog-data-sample",level:2},{value:"Analog Sample Format",id:"analog-sample-format",level:2},{value:"Analog Sample Rate",id:"analog-sample-rate",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Block",id:"block",level:2},{value:"Bytes",id:"bytes",level:2},{value:"CAMARC",id:"camarc",level:2},{value:"Camera Contribution",id:"camera-contribution",level:2},{value:"Characters",id:"characters",level:2},{value:"DEC, Intel, and SGI/MIPS",id:"dec-intel-and-sgimips",level:2},{value:"Endian",id:"endian",level:2},{value:"Floating-point",id:"floating-point",level:2},{value:"Integer",id:"integer",level:2},{value:"Parameters",id:"parameters",level:2},{value:"Raw data",id:"raw-data",level:2},{value:"REAL",id:"real",level:2},{value:"Records",id:"records",level:2},{value:"Residual",id:"residual",level:2},{value:"Section",id:"section",level:2},{value:"Trial",id:"trial",level:2},{value:"UTF-8",id:"utf-8",level:2}];function c(e){const a={h2:"h2",p:"p",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.p,{children:"This glossary contains definitions of terms used in the C3D documentation.  In some cases, terms such as record, blocks, and section, are used in ways that may appear unconventional to many users with a traditional programming background.  The use of these terms in this manual is an attempt to describe the C3D format in a coherent fashion as a vehicle for the accurate storage of universally accessible data in the 3D biomechanics motion capture environment."}),"\n",(0,i.jsx)(a.h2,{id:"3d-data",children:"3D Data"}),"\n",(0,i.jsx)(a.p,{children:"The C3D file format was created to provide a standard method of storing 3D data as coordinates, referenced to a single origin.  All 3D data locations consist of three dimensions, recording the X, Y and Z distance from a single fixed origin that is used to define the recording environment co-ordinate system.  Typically the +Z axis rises vertically from the floor with the direction of progression for motion within the co-ordinate system in the X and Y axes but this is only a convention."}),"\n",(0,i.jsx)(a.h2,{id:"3d-frame",children:"3D Frame"}),"\n",(0,i.jsxs)(a.p,{children:["Each 3D frame consists of one or more 3D data points and analog data samples that can be considered to be the values of the measurement variables at a single instant of time.  This avoids the misunderstandings that can be caused by the use of the terms \u201cVideo Frame\u201d and Video Field\u201d since C3D files are normally created by motion capture systems that sample camera and sensors directly.  All 3D frames are recorded in sequence, at intervals defined by the parameter POINT",":RATE",", which is written as a frequency value in Hertz (cycles per second)."]}),"\n",(0,i.jsxs)(a.p,{children:["A 3D frame may contain zero or more 3D points as recorded in the parameter POINT",":USED",".  Since the C3D format is a general format intended for biomechanical data storage, it is also possible to create C3D files that contain only analog data values without any associated 3D data values.  Note that although a C3D file only contains analog data with no 3D data points, the analog data will be stored as a fixed number of analog samples per 3D Frame."]}),"\n",(0,i.jsx)(a.h2,{id:"3d-point",children:"3D Point"}),"\n",(0,i.jsx)(a.p,{children:"A 3D point is a single measurement of a point in space as an offset from the origin of the measurement system.  In its most basic form this consists of three coordinate measurements (X, Y, and Z) although it is possible to record fewer dimensions by setting any unused coordinates to zero."}),"\n",(0,i.jsx)(a.p,{children:"In addition to the X, Y and Z coordinates, the C3D format supports additional information stored with each 3D point to describe the coordinate measurement properties \u2013 see the descriptions of the Residual and Camera Contribution."}),"\n",(0,i.jsx)(a.h2,{id:"ascii",children:"ASCII"}),"\n",(0,i.jsx)(a.p,{children:"The ASCII standard (American Standard Code for Information Interchange) was created in 1960 to define standard numerical representations for printable characters and functions in the information transfer environment.  The C3D format supports the standard \u201cprintable\u201d 7-bit ASCII characters with no support for formatting such as tabs, bold, underscoring, carriage return, or controls such as SYN, DEL, or ESC."}),"\n",(0,i.jsx)(a.h2,{id:"adc",children:"ADC"}),"\n",(0,i.jsx)(a.p,{children:"An ADC (A/D or A-to-D) is a hardware component that converts analog voltages into digital values that can be recorded in temporal synchronization with 3D measurements, typically enabling force and moment information, together with other biomechanics data such as electromyography and acceleration, to be stored in a C3D file as analog data samples."}),"\n",(0,i.jsxs)(a.p,{children:["The analog data samples generated by an ADC will normally have a fixed digital resolution (typically 12, 14, or 16-bits) and are generated repetitively at a sample rate that defines the bandwidth of the sampled data.  The analog ADC data environment is defined by the ANALOG",":SCALE",", OFFSET, and GEN_SCALE parameters in each C3D file containing analog data."]}),"\n",(0,i.jsx)(a.h2,{id:"analog-data-sample",children:"Analog Data Sample"}),"\n",(0,i.jsxs)(a.p,{children:["Analog data stored in a C3D normally consists of a number of analog measurements that have all been recorded at a single instant of time from each analog channel that is being sampled.  All analog data samples are recorded in sequence at regular intervals defined by the parameter ANALOG",":RATE",", which is written as a frequency value in Hertz.  It is required that every analog data sample must contain the same number of analog measurements defined by the parameter ANALOG",":USED","."]}),"\n",(0,i.jsx)(a.p,{children:"Additional critical factors in recording accurate analog samples are the ADC input range settings, the analog sample rate, and the scaling calculations that convert each data sample into real-world values.  Both the individual ADC input range settings and the ADC sample rate are controlled by the data collection system and any changes that affect the sampled signal must be recorded in the appropriate C3D analog parameters so that the analog data can be accurately reconstructed."}),"\n",(0,i.jsx)(a.h2,{id:"analog-sample-format",children:"Analog Sample Format"}),"\n",(0,i.jsx)(a.p,{children:"The C3D format expects that the format of the stored analog sample from the ADC will be an unsigned 16-bit binary code defined by the resolution of the ADC.  The real-world value of the ADC sample is determined by the voltage range of the ADC channel which must be configured to match the range of the applied analog signal."}),"\n",(0,i.jsxs)(a.p,{children:["The stored binary analog samples are converted into real-world values by the scaling calculations using the ANALOG",":SCALE",", ANALOG",":GEN_SCALE"," and ANALOG",":OFFSET"," parameters."]}),"\n",(0,i.jsx)(a.h2,{id:"analog-sample-rate",children:"Analog Sample Rate"}),"\n",(0,i.jsx)(a.p,{children:"The Nyquist sampling theorem indicates that a minimum of two samples per cycle of the data bandwidth are required to reproduce the sampled signal with no data loss.  Essentially this eliminates the possibility of introducing an aliasing component into the sampled data but does not guarantee that an accurate signal waveform will be recorded and can be reconstructed post-collection.  Accurate data reconstruction of biomedical signals normally requires at least five data samples per maximum data cycle bandwidth."}),"\n",(0,i.jsx)(a.h2,{id:"arrays",children:"Arrays"}),"\n",(0,i.jsx)(a.p,{children:"In FORTRAN and in the parameter section of the C3D file, arrays are stored in column order, i.e. the array"}),"\n",(0,i.jsx)(a.p,{children:"C11    C12    C13"}),"\n",(0,i.jsx)(a.p,{children:"C21    C22    C23"}),"\n",(0,i.jsx)(a.p,{children:"is stored serially in the order C11, C21, C12, C22, C13, and C23. In FORTRAN and C3D parameter notation these elements are written as C(1,1), C(2,1), C(1,2), C(22), C(1,3), C(2,3), and the array is dimensioned as C(2,3)."}),"\n",(0,i.jsx)(a.p,{children:"In programming environments derived from C and C++, an array storing the elements in the same serial order is defined as c[3] [2], with the 2nd subscript varying most rapidly."}),"\n",(0,i.jsx)(a.h2,{id:"block",children:"Block"}),"\n",(0,i.jsx)(a.p,{children:"This manual describes the C3D file as being composed of a number of 512-byte blocks of information.  Various data sections within the C3D file are aligned on multiples of 512 bytes and pointers to sections within the C3D file structure are generally stored as block counts.  The choice of a 512-byte block size for the low-level structure of the C3D file is a historical artifact due to the use of FORTRAN in the original PDP-11 programming environment."}),"\n",(0,i.jsx)(a.p,{children:"The term record is used to describe individual units of information such as parameters and data samples that are stored within various sections in the C3D file.  Individual sections and records within the C3D file may cross 512-byte block boundaries."}),"\n",(0,i.jsx)(a.h2,{id:"bytes",children:"Bytes"}),"\n",(0,i.jsx)(a.p,{children:"Many parameters and data values are recorded in the C3D file as integer values.  In the original C3D implementation, all 8-bit byte values were signed bytes with a range of \u2013127 to +127."}),"\n",(0,i.jsx)(a.p,{children:"However, in some cases, the use of signed bytes limited the range available for parameter storage \u2013 as a result, it is common to find unsigned bytes used in many C3D files yielding numerical ranges from 0 +255 for an unsigned 8-bit byte counter. Note that this does not apply to the bytes defining the group and parameter name lengths which are stored and read as signed bytes to record the locked, or unlocked, status flag."}),"\n",(0,i.jsx)(a.h2,{id:"camarc",children:"CAMARC"}),"\n",(0,i.jsx)(a.p,{children:'Computer Aided Movement Analysis in a Rehabilitation Context (CAMARC) was a project funded in 1989 by the EU that developed a public ASCII file format for the storage and exchange of Clinical Motion Information.  The project aimed to establish a European network of clinical and research centers with manufacturers and health care "end-users", and create a standard approach to Clinical Functional Assessment and Clinical Motion Analysis by defining a universally accessible ASCII data format for the exchange and storage of data.'}),"\n",(0,i.jsx)(a.h2,{id:"camera-contribution",children:"Camera Contribution"}),"\n",(0,i.jsx)(a.p,{children:"The camera contribution value is also called camera mask.  The calculation of a 3D data location requires two or more observers (cameras or sensors).  When more than two observers contribute to the calculation of a 3D location, it is useful to record which of the observers contributed to the calculated measurement.  The C3D point record allows up to seven observers (generally, but not necessarily, cameras) to record whether or not their data was used to generate the 3D Point measurement."}),"\n",(0,i.jsx)(a.p,{children:"This is information specific to each data collection environment and can be very useful for debugging and quality control as it allows a user to identify the cameras (or observers) that produced information used by the 3D calculations that generate the 3D locations stored in the C3D file."}),"\n",(0,i.jsx)(a.h2,{id:"characters",children:"Characters"}),"\n",(0,i.jsx)(a.p,{children:"All characters that are defined in the C3D file format are limited to standard 7-bit ASCII values from decimal 32 to 126.  When characters are used in C3D parameter and group names, only upper case characters A-Z, the underscore \u201c_\u201d and 0-9 are permitted to conform to the C3D standard, and ensure universal compatibility for all software applications."}),"\n",(0,i.jsx)(a.p,{children:"However, user entered data, stored in the LABELS and DESCRIPTIONS parameters or in application specific groups like SUBJECTS and EVENTS, may use alternate UTF-8 character sets, but be aware that applications that do not support UTF-8 encoding may display these incorrectly.  The use of UTF-8 encoding as specified by RFC3629 is permitted but, if ASCII parameters are edited and converted to UTF-8 encoding, then applications may need to extend the parameter array storage to handle the larger byte count."}),"\n",(0,i.jsx)(a.h2,{id:"dec-intel-and-sgimips",children:"DEC, Intel, and SGI/MIPS"}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.strong,{children:"DEC"})," is the default format for data created in a Digital Equipment Corporation environment, typically an RSX-11M or VAX operating system."]}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.strong,{children:"Intel"})," is normally the default format for data created in an MSDOS or Microsoft Windows environment."]}),"\n",(0,i.jsxs)(a.p,{children:[(0,i.jsx)(a.strong,{children:"SGI/MIPS"})," is the default format for data created in a Silicon Graphics Inc., or MIPS Technologies environment, typically RISC based 3D graphics workstations."]}),"\n",(0,i.jsx)(a.p,{children:"As a result of the implementation of the C3D file format in different computing hardware environments, C3D files can use three different endian representations, DEC, Intel, and SGI/MIPS, each of which stores integer and floating-point values in byte different  order \u2013 big endian, or little endian.  These describe the order in which bytes, representing numbers, are stored.  Both the DEC and Intel processors use the little endian method for integer storage where the lowest bytes are stored first while the SGI/MIPS processors use the big endian method. The C3D file endian structure information can be retrieved from the parameter header record at the start of the parameter section."}),"\n",(0,i.jsx)(a.p,{children:"In addition, the floating-point format storage differs between all three processors.  The original floating-point format created by DEC was later modified by Intel and then standardized as the IEEE-754 format used by Intel and SGI/MIPS processors."}),"\n",(0,i.jsx)(a.p,{children:'The IEEE-754 format uses a sign-magnitude representation where the difference between a positive value (e.g. +1) and its negative value (-1) is the MSB of the word, thus zero can have two values, one positive and one negative.  The DEC floating-point format has the same mantissa with a "hidden 1 bit", offset binary exponent to the left of the mantissa, but when the numbers are negative, the DEC format stores the value as the 2\'s complement of the positive value.  So there is no negative zero representation, the DEC format only supports one unsigned zero value.  All formats need to be supported for compatibility and data exchange.'}),"\n",(0,i.jsx)(a.h2,{id:"endian",children:"Endian"}),"\n",(0,i.jsx)(a.p,{children:"This describes the order in which bytes representing a value are stored in computer memory and is either big or little. Big endian means that most significant value is stored first at the lowest storage address, while little endian stores the least significant value first.  Note that within both big endian and little endian byte orders, the individual bits within each byte are always big-endian so bytes are unaffected."}),"\n",(0,i.jsx)(a.p,{children:"Most RISC-based computers and Motorola microprocessors use the big endian approach while Intel processors and DEC processors are usually little endian by default.  The C3D format can use both little endian and big endian orders, and applications supporting the C3D format may see either format when a file is opened. The processor type and endian format of a C3D file can be determined by reading the parameter section header record when a file is opened."}),"\n",(0,i.jsx)(a.p,{children:"Both DEC and Intel processors use the little endian method where the lowest bytes are stored first in memory.  MIPS processors use the big endian method, reversing the storage order."}),"\n",(0,i.jsx)(a.h2,{id:"floating-point",children:"Floating-point"}),"\n",(0,i.jsx)(a.p,{children:"The C3D format supports a single-precision floating-point format stored in 32 bits (two words) in the C3D file \u2013 this is called REAL*4 in FORTRAN documentation and REAL the original C3D documentation.  Each C3D file processor type (DEC, SGI/MIPS and Intel) defines a slightly different internal floating-point format. Intel and SGI/MPIS use the IEEE-754 format, stored in little endian for Intel and big endian format for SGI/MIPS processors."}),"\n",(0,i.jsx)(a.p,{children:'The DEC floating-point format has the same mantissa with "hidden 1 bit", an offset binary exponent to the left of the mantissa, but when the numbers are negative, DEC stores the value as the 2\'s complement of the positive value. This means that the DEC format can only store a zero with no sign associated because, unlike the Intel format, there is no ability to store both positive and negative zero representations.'}),"\n",(0,i.jsx)(a.h2,{id:"integer",children:"Integer"}),"\n",(0,i.jsx)(a.p,{children:"Many parameters and data values are recorded in the C3D file as 16-bit integer values.  In the original C3D implementation, integer values in C3D files were always stored as one\u2019s complement 16-bit signed integers; INTEGER*2 in FORTRAN terms, that is numbers in the range of \u201332767 to +32767."}),"\n",(0,i.jsx)(a.p,{children:"However, in many cases, the use of signed integers and bytes reduces the range available for parameter and data storage \u2013 as a result, it is common to find unsigned integers and bytes used in many C3D files yielding numerical ranges from 0 to +65535 for unsigned 16-bit integers."}),"\n",(0,i.jsx)(a.p,{children:"One\u2019s complement signed Integers (\u201332767 to +32767) remain the default storage format for analog data and parameters associated with signed analog data."}),"\n",(0,i.jsx)(a.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(a.p,{children:"The C3D file format defines a method of recording information about, or associated with, the data contained within the file.  This information is stored in objects called \u201cparameters\u201d which can be floating-point, signed or unsigned integers and bytes, or ASCII values.  Parameters are kept in collections depending on their use \u2013 these collections are called \u201cgroups\u201d and every parameter is a member of a group."}),"\n",(0,i.jsxs)(a.p,{children:["Individual parameters have names, and are generally referred to by placing the group name first separated from the parameter name by a colon e.g., GROUP",":PARAMETER","."]}),"\n",(0,i.jsx)(a.h2,{id:"raw-data",children:"Raw data"}),"\n",(0,i.jsx)(a.p,{children:"The C3D format considers raw data to be the initial, relatively unprocessed, data sample from the data collection environment.  But in a typical 3D photogrammetry environment, the 3D point locations are a result of the motion capture system processing 2D images to calculate a 3D location that is stored in the C3D files as a raw data sample.  The C3D format was originally designed to store analog data as raw data binary sample values from an ADC that can be scaled to real-world values."}),"\n",(0,i.jsx)(a.h2,{id:"real",children:"REAL"}),"\n",(0,i.jsx)(a.p,{children:"The C3D format supports a single-precision floating-point format stored in 32 bits (two words) in the C3D file \u2013 this is called REAL*4 in FORTRAN documentation and REAL the original C3D documentation.  Note that the stored format is affected by the C3D file processor type, DEC, SGI/MIPS, and Intel processors each use a different internal format."}),"\n",(0,i.jsx)(a.h2,{id:"records",children:"Records"}),"\n",(0,i.jsx)(a.p,{children:"The sections within a C3D file contain information stored in records.  This manual will consistently use the term record to describe a unit of data storage within the C3D format.  In this context, the term record should be seen more in the terms of database usage than a file structure."}),"\n",(0,i.jsx)(a.p,{children:"Thus, all C3D files contain a header record (i.e. the header section), parameter records are stored within the parameter section, and data records (3D and/or analog) are stored within the data section etc."}),"\n",(0,i.jsx)(a.h2,{id:"residual",children:"Residual"}),"\n",(0,i.jsxs)(a.p,{children:["The 3D point residual is generated when the location of the associated 3D point recorded in the C3D file is calculated, and records the average accuracy distance of the point, calculated by the photogrammetry software and recorded in POINT",":UNITS"," that documents the intersection of the rays used to generate the 3D point locations.  Low residual numbers indicate that the 3D point locations are more accurate when these numbers are derived from the measured 2D vector data used for the photogrammetry reconstruction and will always be absolute, non-zero values."]}),"\n",(0,i.jsx)(a.p,{children:"Residual values of zero indicate that the point was not directly derived from measurements, i.e. the associated 3D coordinates were estimated by interpolation, affected by filtering, or simulated from a software model.  Negative residual values indicate that the stored 3D point is probably invalid.  It is recommended that all residual calculation methods are fully documented."}),"\n",(0,i.jsx)(a.h2,{id:"section",children:"Section"}),"\n",(0,i.jsx)(a.p,{children:"This manual uses the term section to describe the layout of the information within the C3D file.  C3D files are described as being composed of three sections (the basic sections are header, parameters, 3D data), where each section contains collections of records that store information (parameters, 3D points, analog samples etc.).  A section is always at least one, or more, 512-byte blocks in size."}),"\n",(0,i.jsx)(a.h2,{id:"trial",children:"Trial"}),"\n",(0,i.jsx)(a.p,{children:"A trial is a single motion capture recording, typically lasting from three to twenty seconds, during which the subject may perform an action or stand in a static pose while the motion measurement system generates 3D coordinates from specific locations on, or associated with, the subject.  During the 3D data collection additional analog sensors such as force plates, electromyography systems, and accelerometers, generate detailed information related to the subject that must be synchronized temporally with the 3D data samples that record the sampled 3D locations.  A typical motion collection session consists of multiple trials recorded under identical conditions."}),"\n",(0,i.jsx)(a.h2,{id:"utf-8",children:"UTF-8"}),"\n",(0,i.jsx)(a.p,{children:"Encoding user entered text in UTF-8 offers a few advantages over the traditional ASCII characters expected in a C3D file.  The ASCII character set only supports the Latin alphabet, while UTF-8 supports Chinese, Japanese, Hebrew, Arabic, etc., thus UTF-8 support makes the C3D file format universally accessible."}),"\n",(0,i.jsx)(a.p,{children:"UTF-8 can encode each of the 1,112,064 valid code points in the Unicode code space while remaining backwards compatible with the ASCII character set used in the original C3D format definition.  Therefore, any application that supports UTF-8 will be able to read all C3D files created since the early 1980\u2019s."}),"\n",(0,i.jsx)(a.p,{children:"All C3D group and parameter names must use 7-bit ASCII characters to preserve the universally defined C3D format structure.  UTF-8 is permitted in the individual group and parameter descriptions which may be created in local character sets for localization support.  Note that most C3D parameter string lengths are limited to 255 8-bit characters in length."})]})}function h(e={}){const{wrapper:a}={...(0,r.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,a,t)=>{t.d(a,{R:()=>s,x:()=>o});var n=t(6540);const i={},r=n.createContext(i);function s(e){const a=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(a):{...a,...e}},[a,e])}function o(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:a},e.children)}}}]);