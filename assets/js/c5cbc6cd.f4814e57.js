"use strict";(globalThis.webpackChunkc_3_d_org=globalThis.webpackChunkc_3_d_org||[]).push([[4382],{7434:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"the-3d-point-data-section/analog-data-section/analog-data-integer-format/notes-for-programmers-integer-analog-data","title":"Notes for programmers - Integer Analog Data","description":"1.  By default, all analog samples are stored as 16-bit integers with values from 0 to the maximum resolution of the ADC.  The actual resolution and format of the data may be recorded by setting the optional ANALOGBITS parameter to the actual number of bits used, i.e., the value 12, 14, or 16.","source":"@site/docs/the-3d-point-data-section/analog-data-section/analog-data-integer-format/notes-for-programmers-integer-analog-data.md","sourceDirName":"the-3d-point-data-section/analog-data-section/analog-data-integer-format","slug":"/the-3d-point-data-section/analog-data-section/analog-data-integer-format/notes-for-programmers-integer-analog-data","permalink":"/c3d.org/the-3d-point-data-section/analog-data-section/analog-data-integer-format/notes-for-programmers-integer-analog-data","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Notes for programmers - Integer Analog Data"},"sidebar":"tutorialSidebar","previous":{"title":"Analog Data - Integer Format","permalink":"/c3d.org/the-3d-point-data-section/analog-data-section/analog-data-integer-format/"},"next":{"title":"Description","permalink":"/c3d.org/the-3d-point-data-section/description/"}}');var o=a(4848),r=a(8453);const s={title:"Notes for programmers - Integer Analog Data"},i=void 0,l={},d=[];function c(t){const e={li:"li",ol:"ol",p:"p",...(0,r.R)(),...t.components};return(0,o.jsxs)(e.ol,{children:["\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["By default, all analog samples are stored as 16-bit integers with values from 0 to the maximum resolution of the ADC.  The actual resolution and format of the data may be recorded by setting the optional ANALOG",":FORMAT"," parameter to the value UNSIGNED and the optional ANALOG",":BITS"," parameter to the actual number of bits used, i.e., the value 12, 14, or 16."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["If the ANALOG",":FORMAT"," parameter is UNSIGNED then the ANALOG",":OFFSET"," parameter must be interpreted as an unsigned integer."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["If the ANALOG",":FORMAT"," parameter does not exists then assume that the analog data is stored as positive value as a signed 16-bit integer.  This will be correct most of the time."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["The possibility of 16-bit integer overflow exists when applying the ANALOG",":OFFSET"," parameter to the sampled 16-bit analog data.  It is recommended that all applications perform internal scaling calculations with more than 16-bits of resolution (either 32-bit or floating-point) and check the results to ensure that internal math overflow has not occurred."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["Although it is not recommended, some software applications \u201cauto-zero\u201d analog data values by adjusting the ANALOG",":OFFSET"," parameter.  Thus, for example, 12-bit analog data could easily have varying ANALOG",":OFFSET"," values that are close to 2047 but vary from channel to channel."]}),"\n"]}),"\n",(0,o.jsxs)(e.li,{children:["\n",(0,o.jsxs)(e.p,{children:["The analog scaling calculation converts the binary analog sample data from the ADC into physical world measurement defined by the ANALOG",":UNITS"," parameter, but note that the ANALOG",":UNITS"," value only documents the units of the calculated results, changing the parameter does not affect the scaling calculations."]}),"\n"]}),"\n"]})}function h(t={}){const{wrapper:e}={...(0,r.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(c,{...t})}):c(t)}},8453:(t,e,a)=>{a.d(e,{R:()=>s,x:()=>i});var n=a(6540);const o={},r=n.createContext(o);function s(t){const e=n.useContext(r);return n.useMemo(function(){return"function"==typeof t?t(e):{...e,...t}},[e,t])}function i(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:s(t.components),n.createElement(r.Provider,{value:e},t.children)}}}]);